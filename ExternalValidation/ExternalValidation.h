#ifndef EXTERNALVALIDATION_H
#define EXTERNALVALIDATION_H

#include "Point.h"
#include <vector>	// Vector class
#include <numeric>	// Accumulate
#include <iostream>	// Output
#include <cmath>	// Square root

using namespace std;

/* This class computes 3 External Validation measures on a clustering 
	generated by the K-means algorithm using a ground truth partitioning 
	The measures are the Rand Index, Jaccard Coefficient, and the
	Fowlkes-Mallows Index
*/
class ExternalValidation : public Point
{
private:
	double	tp,		// True Positives
			fn,		// False Negatives
			fp,		// False Positives
			tn;		// True Negatives
	int K, n;		// # of clusters, # of points
	vector<vector<int> > contingencyTable; // Matrix
	vector<int> ni;	// Vector of row sums
	vector<int> mj;	// Vector of column sums

public:

	ExternalValidation() {
		tp = 0.0;
		fn = 0.0;
		fp = 0.0;
		tn = 0.0;
		K = 0;
		n = 0;
	}

	ExternalValidation(int K, int n) {
		tp = 0.0;
		fn = 0.0;
		fp = 0.0;
		tn = 0.0;

		this->K = K;
		this->n = n;
		// For K number of clusters (K-means) and K number of partitions
		// (ground truth) create a K x K matrix
		contingencyTable = vector<vector<int> >(K, vector<int>(K, 0));
		ni = vector<int>(K, 0);
		mj = vector<int>(K, 0);
	}

	void calculateTable(vector<Point>* allPoints) {
		for (int i = 0; i < n; i++) {
			// The cluster assignment generated by K-means
			int clusterId = (*allPoints)[i].getCluster();
			// The partition assignment given by ground truth info
			int partitionId = (*allPoints)[i].getPartition();
			
			contingencyTable[clusterId][partitionId] += 1;
		}

		for (int i = 0; i < K; i++) {
			for (int j = 0; j < K; j++) {
				// Sum of row
				ni[i] += contingencyTable[i][j];
				// Sum of columns
				mj[j] += contingencyTable[i][j];
			}
		}
		
		// Check that the sum total of ni = sum total of mj = n
		if (accumulate(ni.begin(), ni.end(), 0) != n) {
			cout << "Error: sum of ni does not equal n" << endl;
		}
		if (accumulate(mj.begin(), mj.end(), 0) != n) {
			cout << "Error: sum of mj does not equal n" << endl;
		}
	}

	void calculateMeasures() {
		// True Positive: pairs of points with the same cluster label
		// and partition label
		for (int i = 0; i < K; i++) {
			for (int j = 0; j < K; j++) {
				double nij = (double)contingencyTable[i][j];
				tp += nij * nij;
			}
		}

		tp = (tp - n) / 2.0;

		// False Negative: belong to the same partition but not the
		// same cluster
		for (int j = 0; j < K; j++) {
			fn += (double)mj[j] * mj[j];
		}

		fn = (fn / 2.0) - tp;

		// False Positive: belong to the same cluster but not the
		// same partition
		for (int i = 0; i < K; i++) {
			fp += (double)ni[i] * ni[i];
		}

		fp = (fp / 2.0) - tp;

		// True Negative: don't belong to the same cluster or the
		// same partition
		tn = (((double)n * n) / 2.0) - (tp + fn + fp);
	}

	/* Rand Index measures the fraction of point pairs where both the
		cluster and partition labels agree. This can be dominated by
		true negatives.
	*/
	double randIndex() {
		return (tp + tn) / (tp + tn + fp + fn);
	}

	/* Jaccard Coefficient is similar to the Rand Index, but ignores
		the true negatives.
	*/
	double jaccardCoefficient() {
		return tp / (tp + fn + fp);
	}

	/* Fowlkes-Mallows is the geometric mean of the precision and recall
		Precision: the fraction of true or correctly clustered point pairs
		compared to all the point pairs in the same cluster
		Recall: the fraction of correctly labeled point pairs compared 
		to all the point pairs in the same partition
	*/
	double fowlkesMallows() {
		double precision = tp / (tp + fp);
		double recall = tp / (tp + fn);

		return sqrt(precision * recall);
	}
};

#endif // !EXTERNALVALIDATION_H
